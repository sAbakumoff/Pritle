>Give explanations on how JavaScript is being run in browsers.

To run JavaScript code in browsers, the runtime is using multiple techniques that are described in the ECMA specification. The implementation of these techniques may vary for different browsers, but the notion stays the same. The current running code is associated with the *execution context* which is, simply speaking, an object that keeps the state that is required to run the code. When a JS code starts running, the new "global" execution context is initialized. When the function is called, the new "function" execution context is initialized. When a function returns, the associated context is being destroyed. Therefore, it's natural to use the LIFO data structure(stack) to track the execution contexts. The JS runtime has the single stack of execution contexts because JavaScript is the single-threaded language and it can perform only one operation at a time. However, it's entirely possible to run a part of the code *now*, suspend the execution, then run the rest of code at some time later, for example ```setTimeout(()=>{console.log('now and later')}, 5000)``` code sets the timeout right away, but writes to the console 5 seconds later. Another example could be a DOM event handler that is attached to an event immediately, but is invoked when the event actually occurs. That is possible because the DOM API and other Web API's are decoupled from the JS runtime execution. In the future we could start using these API's from web assembly code that is written in another language. So, ```setTimeout``` function is part of the DOM API and "waiting 5 seconds" actually happens outside of JS runtime, but it's the runtime that is responsible for executing the rest of the code ```console.log(...)```. This happens with a help of 2 other techniques defined in the ECMA specification :
* *Job* : the operation that is scheduled when there is no running execution context and the execution context stack is empty
* *JobQueue* : a FIFO(queue) data structure that keeps the scheduled jobs.

In the ```setTimeout``` example the Job that is associated with ```console.log``` code is added to the JobQueue 5 seconds later. It's not guaranteed that the Job will be executed immediately, but once the stack of execution contexts is empty and the Job in the head of the queue, the new execution context associated with the job is pushed to the stack and then runs normally. It works the same way for any code that is spread out over the time - Ajax Calls, Event Handlers, SetTimeout and SetInterval.

>How to achieve multithreading in code?

The only way to actually achieve multithreading is using WebWorker API. The code of web-worker is run in the separate, worker thread.
